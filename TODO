LocalIndex and LocalTGraph need to check for loops
Probability needs to check for div/0 errors

(cleanup)
- review Maps.viewSubMap
- review CompositeMap, MeanEntropyComposer
- test ProbabilityEntropyTGraphComposer, ProbabilityIndexComposer

(laterz)
- rename Probability to just Prob?
- rename SPUProbabilityInferer to ShortPathUnionProbInferer?
- possibly move AddressScheme.pushNode* into ProtoAddressScheme

(very later)
- add tags.rout.IndexComposer to the design document
- explain how tags are scored, in the design document


(architecture issues)
current architecture has each QueryProcessor spawn new Contact/Naming/Routing
layers. ideally, Contact should be split off from this, since the information
it uses is independent of any query.

to do this we first need to extend MessageReceiver.recv() to accept a "sender"
argument, or something.



In Kleinberg's model, geographic location is a uniting factor. In this model,
language is a uniting factor.

Dynamic following of hyperlinks...

----

make Producer use a igraph.Graph to store tag arcs

get tag clusters round
get photo contexts round


generateContentArcs:
	user-* arcs:
		inferContentArcs(fave photos)
	group-group arcs:
		inferContentArcs(TODO some subset of docset)


def inferContentArc(photos):
	for photo in photos:
		get producers from photos_getAllContexts (groups) and photos_getInfo (owner)

	for each producer in our sample
		inferTagsetArc(our cover set, producer cover set)


def inferTagsetArc(tset_s, tset_t, tcdb):
	"""
	Given a source tag-set and a target tag-set, infer the tags that the source
	should point to the target with, if any.

	@param tset_s: source tag-set
	@param tset_t: target tag-set
	@param tcdb: tag:[cluster] database
	"""
	for tag in tset_s:
		for cluster in tcdb[tag]:
			if tset_s significantly intersects cluster:
				- link to intersected tags
				- link to top tags of cluster, what weights?




