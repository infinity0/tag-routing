# TODO and related tags

- `DIAG`: draw diagrams for the given concept being discussion
- `TODO`: open issue; resolve or explain why we leave it open
- `MORE`: expand
- `OPEN`: point intentionally left open for future research.
- `EXTN`: external issue for which research / infrastructure already exists

# Introduction

Distributed network of data structures maintained by multiple independent
parties.

Most of the routing power of the system is delegated to the underlying social
network and the innate information-retrieval heuristics we have as humans,
rather than being inherently built into the system.

## Terminology

- identity - a user / node on the social network
- tag - a semantic phrase used for describing objects
- object - depending on context this will either mean generic storage object,
  or "indexes and tgraphs"
- pointer - an indirection to some external resource
- mapping - a pointer that also has a "source" as well as a target


# Overview

The system has three main networks / planes of information that link to each
other.

- routing plane - see the `index` section
- meta-routing plane - see the `tgraph` section
- social plane - see the `ptable` section


# Design assumptions

## Underlying storage network

System is independent of implementation of storage network.

Data structures for now are assumed to be located abstractly "on the network"
(rather than on the node of the maintainer) and can be retrieved at some cost
which increases polynomially wrt the size of the data.

This allows us to avoid dealing with the issue of churn.

This also forces us to consider a iterative routing algorithm rather than a
recursive one. The requestor pulls in data, then pulls in further data, etc,
instead of passing on requests and waiting for replies.

## Network operations

The system will be running on top of a distributed storage network. To preserve
layering and its advantageous, we will define an adapter interface which
converts our abstract higher-level functions into lower-level ones.

	interface NetworkAdapter {

		Map<Identity, IdScore> getFriends(Identity id);

		PTable getPTable(Identity id);

		Index getIndex(ObjectID id);

		TGraph getTGraph(ObjectID id);

	}

The implementation of these will depend on which storage network we happen to
be using at the time, and should be fairly straightforward.


# Data structures

## `index`

DIAG

Maps tags to documents and other indexes.

This data structure contains information on how to satisfy a search request. It
contains mappings from tags to target documents, or to another index to forward
the request onto.

A mapping indicates some semantic relevance between the tag and the document,
and a subjective judgement that a person searching for the tag did intend to
retrieve information provided by the document.

The network formed by the links between indexes is conceptually analogous to
the network of routing tables existent in most typical navigable networks, and
so we'll call it the "routing plane".

## `tgraph`

DIAG

Maps tags to other tags and other tgraphs.

This data structure contains information on how to traverse the routing
network. It contains mappings from tags to other tags, or to another tgraph
containing more data.

A mapping indicates a semantic relationship between the tags, and a subjective
judgement that an index specialising in the target tag is likely to contain
entries for the source tag.

The purpose of defining such a semantic relationship is to provide a framework
for traversing through index data. On most typical networks this framework is
encoded into the addressing scheme. For example, numerical addresses (such as
IP addresses) are naturally hierarchical, and can be prefix-matched on routing
tables. Tags however do not intrinsically encode such information, so we need
an extra plane to provide it.

Conceptually, a tag can be thought of as a pure name (ie. the name conveys no
information about the location of the target), and IP addresses as the exact
opposite. DNS names are somewhere in between - a name like "www.example.com"
provides some information on its location (ie. the subdomain hierarchy), but we
still need to start at the root servers.

The network formed by the links between tgraphs can be used to generate schemes
for traversing the routing data, and so we'll call it the "meta-routing plane".

## `ptable`

DIAG

A collection of pointers to tgraphs and indexes, linked to an identity. (Can
also be thought of as a mapping whose source is implicitly the identity who
defines the pointer.)

This data structure allows an identity to declare a personal list of preferred
indexes and tgraphs to use for routing purposes.

This is intended to provide a secure way of "bootstrapping" onto the routing
and meta-routing planes.

MORE

# Pointer weights

Each pointer will be assigned a weight. These weights can be used to decide:

- priority of traversal of the routing and meta-routing networks
- ranking of query results

A natural way to compose two weights is multiplication, which gives rise to
the restriction that all weights must be in the interval [0,1].

There are several types of pointers:

- tag:routing (index) mappings
- tag:meta-routing (tgraph) mappings
- id:object (ptable) mappings

The precise meaning of a pointer's weight is intrinsically interdepedent with
the routing algorithm. Probability-based semantics are likely to be more robust
and reliable, since these are objective properties and can (in theory) be
estimated algorithmically. (It also fits well with multiplication and the [0,1]
interval restriction).

Note that, regardless of their absolute semantic meaning, weights of pointers
from the same object can be used to calculate the relative preferences of the
targets, from the point of view of that object.

Some possible candidates are: TODO

- tag:routing mapping
	- probability that a given mapping will satisfy a user's request
	- TODO
- tag:meta-routing mapping
	- probability that a search for the target tag will return results for the
	  source tag
	- TODO
- id:object mapping
	- probability that a ***
	- TODO

These weights allow algorithms to achieve a finer level of preference-choosing
than would otherwise be possible. However, care must be taken not to depend on
the precise values too much, or to treat the data as authoritative: even if
malicious data can be excluded, and the weights are defined on some objective
property, there will still be some degree of inconsistency between different
objects, since each publisher can only calculate weights from their subjective
(and limited) view of the entire network.

The best practical solution would be to install an automatic way of assigning
weights to pointers. This would reduce the problem of human inaccuracy, as well
as laziness: it's tedious to manually estimate a weight for every pointer we
add to our collections. [OPEN]

## Zero-weight pointers

The current design can only represent the presence of a semantic relationship,
and not its absence. This is a problem: any distributed system has to be able
to deal with incomplete information, but here there is no way to tell if the
absence of a pointer is due to incomplete information, or explicit rejection
of the semantic relationship that the pointer represents. This is important for
when (eg.) we want to combine weights from multiple sources - we need to know
whether others disagree with a given mapping, or merely don't know about it.

Requiring explicit "zero-weight" pointers is not acceptable for our purposes,
since this equates to defining *something* (either a relationship or its
absence) between *all* possible pairs of objects encountered; this results in
quadratic data growth, which is not scalable.

Instead, we will look at heuristics that attempt to resolve this ambiguity.

For an object consisting of mappings, such as `index` and `tgraph`, we observe
that tha presence of a mapping (S,T) indicates that the maintainer knows of the
existence of both S and T, and has enough information to make judgements about
them ("knows about" S and T). Further, the maintainer has enough information to
decide whether to include a mapping between *any* source and *any* target that
it "knows about".

Conversely, for any given mapping (X,Y) *not* present in the object, if the
object nevertheless "knows about" both X and Y, then it seems reasonable to
conclude that the absence of the mapping more likely represents a zero-weight
pointer (ie. non-relationship), rather than "missing information".

- For a `tgraph` $g$, we guess that any $(t_1,t_2) \notin g$, with $t_1, t_2
  \in dom(g) \cup img(g)$, is "probably" a zero-weight pointer and not "missing
  information".
- For an `index` $i$, we guess that any $(t,d) \notin i$, with $t \in dom(g)$
  and $d \in img(g)$, is "probably" a zero-weight pointer and not "missing
  information".

Specific examples of this general principle, as well as applications of it,
will be explored further in relevant sections of the [Algorithms](#algorithms)
chapter.

For an object consisting only of source-less pointers, such as `ptable`, there
is no information within a single object that could be used for any heuristic
to distinguish the two cases.^[Using the heuristic described above for mappings
by treating the pointers as mappings from a single source doesn't help: a pair
(X,Y) cannot exist with the required properties since we only have one source.]

However, in the specific case of `ptable`, we could use the links present in
the social network to infer more information: eg. identities who are friends
are likely to "know about" similar sets of objects. In practice, such methods
are hard to get accurate^[A basic heuristic would be to assume that some
fraction of an identity's friends "know about" each object that its `ptable`
points to; however the real fraction is unlikely to be near-constant over all
objects, so the scheme would greatly disadvantage rare objects. We could take
this into account and estimate the "knows about" fraction based on the fraction
of identities that explicitly reference the target, but this is becoming more
and more complicated with increasingly hand-waving arguments.], and probably
won't provide significantly enough benefit to justify the additional complexity
- the social network should mitigate most serious attempts to abuse the system.
MORE

## Negative-weight pointers

A related issue is negative-weight pointers, which would represent a judgement
that the target is malicious (in some sense), rather than neutral or "useless".
In a network where it's possible to act aggressively towards particular nodes,
these weights could provide information on who to attack (or equivalently, set
up defences against), and in what way.

As it stands, our routing system is a "dumb" network of data; the only way of
interacting with other nodes is by publishing data objects for other nodes to
read. We are unable to see other nodes' read requests, so it's impossible to
attack a particular node. Hence, negative-weight pointers are not useful here.

There are several other complications with negative-weight pointers in general.
These would be relevant if our routing system is adapted into a form where one
*can* perform targeted acts of aggression.

- If positive-weight pointers are taken to be probabilities, it's not obvious
  what negative-weight pointers should mean. If the semantics of the data
  structure are not well-defined, the algorithms that use it cannot be, either.
- Depending on the algorithm used to combine weights from multiple sources,
  negative weights may allow the weight system itself to be used as an attack
  vector. (Otherwise, this was already possible with positive-only weights and
  the introduction of negative weights makes no difference.)
- MORE


# Algorithms

Since network latency is far greater than processing latency, we will design
these algorithms to be inherently concurrent.

## Obtaining initial ptables

Assume a given identity is already connected to the social network. MORE

Bootstrapping is an independent issue that applies to all systems whose core
functionality depends on a social network. Luckily such systems are already
widely deployed on the www; new networks can bootstrap themselves by extracting
social data from existing networks in the form of invites, etc. [EXTN]

For our purposes, we need an algorithm which takes our own identity as input,
and outputs a set of identities to seed our routing algorithm with, possibly
with a weight associated with each identity.

	interface SeedSetGetter {

		Map<Identity, IdScore> getSeedSet(Identity self);

	}

A basic implementation of this would be to return all nodes up to 2 hops away
from our own node. This would grab a decent number of nodes whilst offering
a basic level of protection against the most common and simple attacks.

Inferring attackers based on the link-structure of a social network is a whole
topic in itself; more advanced algorithms exist that can detect and avoid more
sophisticated attacks. The important thing here is that this component of our
system is indepedent of the rest, and can always be upgraded to a more advanced
scheme, including future ones not yet invented.

## Combining multiple `ptable` objects

Given a set of `ptable`s $P_s = {(p_i, w_i)}$ ($p_i$ distinct);

Return $p$ that "combines" all the information, with $dom(p) = \bigcup dom(p_i)$.
In other words, combine weight ratings for each object.

Now define $G_s \subseteq G$ and $I_s \subseteq I$ such that $G_s + I_s = dom(p)$

## Meta-routing

### Combining `tgraph` objects

Given a working set of `tgraph`s $G_w = {(g_i, w_i)}$ and tag $t$;

Return ${(g, w)}$, a set of mapping targets (which can be a tag or tgraph) and
their weights; the source of each mapping being $t$.

### Determining `tgraph` traversal order

Given a working set of `tgraph`s $G_w = {(g_i, w_i)}$ and a partial spanning
tree $T_w$ rooted at $t_0$

Return an ordered list of tags ${t_i}$ to add to the tree.

If the first element can be added to the tree immediately, we will do so, and
call the method recursively, ignoring the other elements returned. In the other
case (`tgraph`) we will need to wait for the object to be retrieved from the
network; in the meantime we can go through the list and add the other elements,
applying the same principle to $t_1$, etc...

### Weight of a `tgraph` not in the working set

Given a working set of `tgraph`s $G_w = {(g_i, w_i)}$ and a new `tgraph` $g_n$;

Return a weight $w_n$.

MORE note the two different semantic meanings for pointer weights being used
here (relevancy vs reliability) TODO explore this and its potential pitfalls

## Routing

DIAG

The data structure we use to keep track of routing progress is a working tree
of tags, $T_w$, with each node (tag $t$) in the tree being associated with a
working `index` set, $I_w[t]$.

Intially, $T_w$ contains only our original search term $t_0$, and we associate
it with $I_s$, our seed set (see [above](combining-multiple-ptable-objects)).

In the background, $T_w$ will continually have new tags being added to it, by
the [meta-routing]() algorithms. When a new tag is added, we need to detect
this, and initialise its working index set with a copy of its parent's.

Meanwhile, we search every index in every working set for every tag, in some
appropriate order. Each result set returned for a given query $(i,t)$ will
remain associated with the query; this is useful for the [ranking]() algorithm.
If the result set points to a new index $i'$, that might contain additional
entries for $t$ and terms related to it. In this case, we will add such queries
to our queue, by adding $i'$ to the working set of $t$, and that of all its
ancestors and descendents too.

### Determining `index` query order

Given a working tree $T_w$ with a working index `set` mapping $I_w[t]$, and
knowledge of which queries have already completed;

Return an ordered list of (index, tag) pairs {(i_i, t_i)} to perform queries
on.

Tags further away from the root are less "related" to the original query, but
searches for them are more likely to succeed, so the algorithm should proceed
by searching near the root, then further up the tree.

MORE same principle about concurrency as mentioned before about tag/tgraphs.


## Ranking


# Optimisations

## Querying an `index` or `tgraph` for presence of a source tag

Bloom filters

## Querying an `index` or `tgraph` for weight of an external target

...


# UI

## Components

## Behaviour


# Design rationale and issues

## Initial requirements

## Identity-object pointers

vs. all-data-in-identity and identity-identity pointers

## Object-object pointers vs identity-object pointers

to decrease the number of identity-object pointers

## Mutable-object pointers vs immutable-object pointers



