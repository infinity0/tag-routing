# TODO

- `DIAG`: draw diagrams for the given concept being discussion
- `OPEN`: open issue; resolve or explain why we leave it open
- `MORE`: expand

# System summary

Distributed network of data structures maintained by multiple independent
parties.

Most of the routing power of the system is delegated to the underlying social
network and the innate information-retrieval heuristics we have as humans,
rather than being inherently built into the system.

Some terminology:

- identity - a user / node on the social network
- tag - a semantic phrase used for describing objects
- object - depending on context this will either mean generic storage object,
  or "indexes and tgraphs"
- pointer - an indirection to some external resource
- mapping - a pointer that also has a "source" as well as a target


# System overview

The system has three main networks / planes of information that link to each
other.

- routing plane - see the `index` section
- meta-routing plane - see the `tgraph` section
- social plane - see the `ptable` section


# Design assumptions

## Underlying storage network

System is independent of implementation of storage network.

Data structures for now are assumed to be located abstractly "on the network"
(rather than on the node of the maintainer) and can be retrieved at some cost
which increases polynomially wrt the size of the data.

This allows us to avoid dealing with the issue of churn.

This also forces us to consider a iterative routing algorithm rather than a
recursive one. The requestor pulls in data, then pulls in further data, etc,
instead of passing on requests and waiting for replies.


# Data structures

## `index`

DIAG

Maps tags to documents and other indexes.

This data structure contains information on how to satisfy a search request. It
contains mappings from tags to target documents, or to another index to forward
the request onto.

A mapping indicates some semantic relevance between the tag and the document,
and a subjective judgement that a person searching for the tag did intend to
retrieve information provided by the document.

The network formed by the links between indexes is conceptually analogous to
the network of routing tables existent in most typical navigable networks, and
so we'll call it the "routing plane".

## `tgraph`

DIAG

Maps tags to other tags and other tgraphs.

This data structure contains information on how to traverse the routing
network. It contains mappings from tags to other tags, or to another tgraph
containing more data.

A mapping indicates a semantic relationship between the tags, and a subjective
judgement that an index specialising in the target tag is likely to contain
entries for the source tag.

The purpose of defining such a semantic relationship is to provide a framework
for traversing through index data. On most typical networks this framework is
encoded into the addressing scheme. For example, numerical addresses (such as
IP addresses) are naturally hierarchical, and can be prefix-matched on routing
tables. Tags however do not intrinsically encode such information, so we need
an extra plane to provide it.

Conceptually, a tag can be thought of as a pure name (ie. the name conveys no
information about the location of the target), and IP addresses as the exact
opposite. DNS names are somewhere in between - a name like "www.example.com"
provides some information on its location (ie. the subdomain hierarchy), but we
still need to start at the root servers.

The network formed by the links between tgraphs can be used to generate schemes
for traversing the routing data, and so we'll call it the "meta-routing plane".

## `ptable`

DIAG

A collection of pointers to tgraphs and indexes, linked to an identity. (Can
also be thought of as a mapping whose source is implicitly the identity who
defines the pointer.)

This data structure allows an identity to declare a personal list of preferred
indexes and tgraphs to use for routing purposes.

This is intended to provide a secure way of "bootstrapping" onto the routing
and meta-routing planes.

MORE

## Pointer weights, &alpha;

Each pointer will be assigned a weight. These weights can be used to decide:

- priority of traversal of the routing and meta-routing networks
- ranking of query results

A natural way to compose two weights is multiplication, which gives rise to
the restriction that all weights must be in the interval [0,1].

There are several types of pointers:

- tag:routing (index) mappings
- tag:meta-routing (tgraph) mappings
- id:object (ptable) mappings

The precise meaning of a weight has not been decided yet, and is likely to
depend on the specifics of the routing algorithm. Probability-based semantics
are likely to be quite robust and reliable, since these can (in theory) be
estimated objectively. It also fits well with multiplication and the [0,1]
interval restriction.

Some possible candidates are: OPEN

- tag:routing mapping
	- probability that a given mapping will satisfy a user's request
	- OPEN
- tag:meta-routing mapping
	- probability that a search for the target tag will return results for the
	  source tag
	- OPEN
- id:object mapping
	- probability that a ***
	- OPEN

These values allow for a finer level of processing and ranking that would
otherwise be possible; however, care must be taken not to treat any of these
values as authoritative, since users can input whatever values they wish.
The same goes for creating the pointers in the first place; however, assigning
weights to pointers is more complex than a binary existence decision, and so
it will be harder to both decide accuracy and resolve disagreements.

Note that, regardless of their absolute semantic meaning, weights of pointers
from the same object can be used to calculate the relative preferences of the
targets.

Ultimately, the best solution would be to install an automatic way of assigning
weights to pointers. This would solve the problem of human inaccuracy, as well
as laziness: it's tedious to manually estimate a weight for every pointer we
add to our collections.

## Absent and negative pointers

Absence of pointers - does this mean "irrelevant", or information missing?

Negative pointers - don't have these, why not?


# Algorithms

## Obtaining initial ptables

## Combining tgraphs

## Combining &alpha; ratings for indexes

## Routing

### Traversing the `tgraph` network

### Traversing the `index` network

## Ranking


# UI

## Components

## Behaviour


# Design rationale and issues

## Initial requirements

## Identity-object pointers

vs. all-data-in-identity and identity-identity pointers

## Object-object pointers vs identity-object pointers

to decrease the number of identity-object pointers

## Mutable object pointers vs immutable object pointers



