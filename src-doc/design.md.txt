# Meta

## Terminology

- identity - a user / node on the social network
- document - a storage object that can be the target of a query. (This could
  include multimedia or software; we'll refer to all of these as "document" for
  simplicity.)
- tag - a phrase that can be semantically attached to a storage object
- pointer - an indirection to some external resource
- mapping - a pointer that also has a "source" as well as a target

## Symbols

With no other context, the following symbols refer to the following object
types; capitalised symbols refer to the set of all objects of the given type.

- $g$ - `tgraph`
- $h$ - `index`
- $p$ - `ptable`
- $d$ - document
- $t$ - tag
- $z$ - identity
- $w$ - weight or identity score

## Notation

- $f \subseteq X \to Y$ - $f$ is a partial function from set $X$ to set $Y$

## TODO and related tags

- `DIAG`: draw appropriate diagram here
- `TODO`: open issue; resolve or explain why we leave it open
- `MORE`: expand
- `EXTN`: a pointer to an external research topic, either potential or existing
- `REF`: add references for


# Overview

Distributed network of data structures maintained by multiple independent
parties.

Most of the routing power of the system is delegated to the underlying social
network and the innate information-retrieval heuristics we have as humans,
rather than being inherently built into the system.

How the properties of the system (performance, scalability, robustness) change
with the structure of the network forms the basis of the [analysis](#analysis).

The system has three main networks / planes of information that link to each
other.

- routing plane - see the `index` section
- meta-routing plane - see the `tgraph` section
- social plane - see the `ptable` section


# Specification

## Data structures

### `tgraph`

DIAG

Structure
:	$g \subseteq (T \times T \cup G) \to W$
Description
:	Maps tags to other tags and other tgraphs, each mapping having a weight.

This data structure contains information on how to traverse the routing
network. It contains mappings from tags to other tags, or to another tgraph
containing more data.

A mapping indicates a semantic relationship between the tags, and a subjective
judgement that an index specialising in the target tag is likely to contain
entries for the source tag.

The purpose of defining such a semantic relationship is to provide a framework
for traversing through index data. On most typical networks this framework is
encoded into the addressing scheme. For example, numerical addresses (such as
IP addresses) are naturally hierarchical, and can be prefix-matched on routing
tables. Tags however do not intrinsically encode such information, so we need
an extra plane to provide it.

Conceptually, a tag can be thought of as a pure name (ie. the name conveys no
information about the location of the target), and IP addresses as the exact
opposite. [REF]

The network formed by the links between tgraphs can be used to generate schemes
for traversing the routing data, and so we'll call it the "meta-routing plane".

### `index`

DIAG

Structure
:	$h \subseteq (T \times D \cup H) \to W$
Description
:	Maps tags to documents and other indexes, each mapping having a weight.

This data structure contains information on how to satisfy a search request. It
contains mappings from tags to target documents, or to another index to forward
the request onto.

A mapping indicates some semantic relevance between the tag and the document,
and a subjective judgement that a person searching for the tag did intend to
retrieve information provided by the document.

The network formed by the links between indexes is conceptually analogous to
the network of routing tables existent in most typical navigable networks, and
so we'll call it the "routing plane".

### `ptable`

DIAG

Structure
:	$p_z \subseteq G \cup H \to W$
Description
:	For some given identity $z$, points to `tgraph` and `index` objects, each
	pointer having a weight.^[Each pointer can also be thought of as a mapping
	whose source is implicitly $z$]

This data structure allows an identity to declare a personal list of preferred
indexes and tgraphs to use for routing purposes.

This is intended to provide an attack-resistant "bootstrapping" path onto the
routing and meta-routing planes.

MORE

### Pointer weights

Structure
:	$w \in W = [0,1]$
Description
:	Aids comparison and composition of multiple pointers or mappings.

The precise meaning of a pointer's weight is intrinsically linked with what the
routing and the ranking algorithms do. Specific uses include:

- priority of traversal of the routing and meta-routing networks
- ranking of query results

Probability-based semantics seem quite robust and reliable, since these are
objective properties and can (in theory) be estimated algorithmically. It also
gives rise to a simple way of combining weights (multiplication), as well as a
simple interval of values [0,1].

There are several types of pointers; some possible candidates to what they
should represent are: TODO

- tag:routing mapping
	- probability that a given mapping will satisfy a user's request
- tag:meta-routing mapping
	- probability that a search for the target tag will return results for the
	  source tag
- id:object mapping
	- probability that a ***

These weights allow algorithms to achieve a finer level of preference-choosing
than would otherwise be possible. However, care must be taken not to depend on
the precise values too much, or to treat the data as authoritative: even if
malicious data can be excluded, and the weights are defined on some objective
property, there will still be some degree of inconsistency between different
objects, since each publisher can only calculate weights from their subjective
(and limited) view of the entire network.

The best practical solution would be to install an automatic way of assigning
weights to pointers. This would reduce the problem of human inaccuracy, as well
as laziness: it's tedious to manually estimate a weight for every pointer we
add to our collections. [EXTN]

## Algorithms

Since network latency is far greater than processing latency, we will design
these algorithms to be inherently concurrent. Operations involving retrieval
of remote objects will be non-blocking and allow other work to be done whilst
waiting for its results.

The entire system is constructed from various components, detailed below. Most
of them are interesting problems in themselves from a wide range of topics; as
research advances, each component can be upgraded independently.

### Initialisation

MORE blah blah, why etc

MORE only need to do this one, and then keep track of minor updates etc.

#### Obtaining initial ptables

Assume a given identity is already connected to the social network. MORE

Any system whose core functionality depends on a social network needs a method
of constructing a base network which is large enough. Luckily such systems are
already widely deployed on the www; new networks can bootstrap themselves by
extracting social data from existing networks, through invites, etc. [EXTN]

For our purposes, we need an algorithm which takes our own identity as input,
and outputs a set of identities to seed our routing algorithm with, possibly
with a weight associated with each identity.

Given
:	- our own identity
Return
:	- a set of seed identities, with corresponding scores

A basic implementation of this would be to return all nodes up to 2 hops away
from our own node. This would grab a decent number of nodes whilst offering
a basic level of protection against the most common and simple attacks. A
variation would be to filter out the 2-hop nodes that share very few mutual
1-hop friends with us (by some standard); this would be slightly harder to
attack.

Inferring attacks from the link structure of a social network is outside the
scope of this project. More advanced algorithms exist; a real implementation of
this system would be able to use the latest available techniques. [REF][EXTN]

#### Combining `ptable` objects

Given
:	- a map $P_s = \{(p_i, u_i)\}$ of `ptable`s to their identity scores
Return
:	- a `ptable` $p$ that "combines" this information, with $dom(p) = \bigcup
	  dom(p_i)$.

Define $G_s = dom(p) \cap G$ and $H_s = dom(p) \cap H$. (Note that $G + H =
dom(p)$).

A basic implementation is just to calculate the score-weighted average^[These
weights are [limited in range](#pointer-weights), and so should be resistant to
average-manipulation attacks] of the weight of each pointer target, ie:

$p[o] = \bar{\omega} = \frac{\sum_i u_i \omega_i}{\sum_i u_i}$

where $\omega_i$ is the adjusted weight of a pointer to $o$ in $p_i$, inferring
between a zero-weight pointer and "missing information" (see [Zero-weight
pointers](zero-weight-pointers)):

$$
\omega_i = \left\{
\begin{array}{lll}
 w_i = p_i[o]        & : \quad & o \in p_i \\
 \alpha.\bar{\omega} & : \quad & o \notin p_i \\
\end{array}
\right.
$$

where $\alpha$ is the probability of $o \notin p_i$ being due to "missing
information".

TODO derive the non-recursive form of this.

Here we need to determine realistic values for $\alpha$. There are various
possible ways of doing this, typically by using training data collected from a
real network. More advanced techniques include collecting data directly from
the active network to adjust the values dynamically; this has the advantage
that the training data is more relevant to the trainee. [EXTN]

Such methods are likely to be quite complex, so to keep things simple for this
project, we use a constant estimate of $\alpha = 0.5$.^[Intuitively, for any
given target, $P(like)$ and $P(know)$ are low but slightly correlated, so
$P(\neg like \wedge \neg know)$ is high, but not very high.]

### Meta-routing

We want to construct a routing scheme from the `tgraph` plane, which will be
relative to some given root tag $t_0$. Since `tgraph` data is distributed
across many objects, we need various methods of combining these into a single
tree of tags.

We start from our seed `tgraph` set $G_s$. If $t_0$ does not appear in $G_s$,
we have a few backup options:

- ask the user to supply some related tags. This should not be a significant
  problem; people usually "have an idea" of what they are looking for.
- ask more nodes in the social graph for their `ptable`s. This can be done
  automatically, which makes things more convenient for a user. However, it
  increases the risk of an attack through the social network.

MORE

#### Combining `tgraph` objects

Given
:	- a working map $G_w = \{(g_i, u_i)\}$ of `tgraph`s to their weights
	- a source tag $t$
Return
:	- a map $\{(x_j, w_j)\}$ of `tgraph` mapping targets (ie. a tag or tgraph)
	  and their weights; the source of each mapping is implicitly $t$.

A basic implementation is just to calculate the `tgraph`-weighted average of
the weight of the mapping $(t, x_j)$, ie:

$w_j = \bar{\omega} = \frac{\sum_i u_i \omega_i}{\sum_i u_i}$

where $\omega_i$ is the adjusted weight of the mapping $(t, o)$ in $g_i$,
inferring between a zero-weight pointer and "missing information" (see
[Zero-weight pointers](zero-weight-pointers)):

$$
\omega_i = \left\{
\begin{array}{lll}
 g_i[t, x_j]         & : \quad & (t, x_j) \in g_i \\
 \alpha.\bar{\omega} & : \quad & (t, x_j) \notin g_i \wedge x_j \in dom(g_i) \cup img(g_i) \\
 \beta.\bar{\omega}  & : \quad & (t, x_j) \notin g_i \wedge x_j \notin dom(g_i) \cup img(g_i) \\
\end{array}
\right.
$$

where $\alpha$ and $\beta$ is the probability of $(t, x_j) \notin g_i$ being
due to "missing information", given whether $g_i$ "knows about" $x_j$.

TODO derive the non-recursive form of this.

This is essentially the same algorithm that we use to [combine
`ptable`s](#combining-ptable-objects), with additional tweaks to take advantage
of the additional tag information present here.

Like the other algorithm, we need to determine realistic values for $\alpha$
and $\beta$. The same points apply here, and again for temporary simplicity we
will pick $\alpha = $ and $\beta = $. TODO

#### Determining `tgraph` traversal order

Given
:	- a working map $G_w = \{(g_i, w_i)\}$ of `tgraph`s to their weights
	- a working tree $T_w$ of tags
Return
:	- an ordered list $[(t_i \in T_w, x_i, w_i)]$ of `tgraph` mappings to add
	  to the tree

A basic implementation can simply return the "nearest" node to the root not
already in the tree, where "distance" of a path is defined as the negative log
of the product of its arc weights. MORE

If the first element can be added to the tree immediately, we do so, and call
the method recursively, ignoring the other elements returned. In the other case
(`tgraph`) we need to wait for the object to be retrieved from the network; in
the meantime we can go through the list and add the other elements, applying
the same principle to $t_1$, etc...

#### Weight of a `tgraph` not in the working set

Given
:	- a working map $G_w = \{(g_i, w_i)\}$ of `tgraph`s to their weights
	- a new `tgraph` $g_n \notin dom(G_w)$
Return
:	- a weight $w_n$ to assign to $g_n$

MORE note the two different semantic meanings for pointer weights being used
here (relevancy vs reliability) TODO explore this and its potential pitfalls

### Routing

DIAG

The data structure we use to keep track of routing progress is a working
(mutable) tree of tags, $T_w$. For each tag $t \in T_w$, we keep track of its
working `index` set, $H_w[t]$, and its queried `index` set, $H_c[t] \subseteq
H_w[t]$. For each index $h \in H_c[t]$, we also keep track of the results that
the query $(h, t)$ returned, as $R_c[t][h]$.

Define $Q_p(T_w, H_w) = \{(h,t): t \in T_w, h \in H_w[t]\}$, the set of all
possible queries to be made.

Initially, $T_w$ contains only our original search term $t_0$, and we let
$H_w[t_0] = H_s$, our [seed set](#combining-multiple-ptable-objects)).

In the background, $T_w$ will be continually having new tags added to it, by
the [meta-routing]() algorithms. When a new tag is added, we need to detect
this, and initialise its working index set with a copy of its parent's.

Meanwhile, we perform the queries in $Q_p(T_w, H_w)$ in some appropriate order.
Multiple queries can be performed in parallel; this should not affect the final
output (including ranking of results, etc), for a given final tracking state
$(T_w, H_w, H_c, R_c)$.

When a query $(h, t)$ completes, we update $H_c[t]$ and $R_c[t][h]$ accordingly.
If the result set contains any new index pointers, these may contain additional
entries for $t$ and terms related to it. In this case, we add such queries to
our queue, by adding $h'$ to the working set of $t$, and that of all its
ancestors and descendents too.

This algorithm has no natural logical termination condition; the queries can
theoretically proceed indefinitely until the entire network has been searched.
In practice, we would automatically pause the search after a given number of
results have been returned, and probably give the user the option to resume
from the paused state, resources permitting.

#### Determining `index` query order

Given
:	- a working tree $T_w$ of tags
	- a map $H_w$ of each $t \in T_w$ to its "working `index`" set
	- a map $H_c$ of each $t \in T_w$ to its "queried `index`" set
Return
:	- an ordered list $[(h_i, t_i)] \subseteq Q_p(T_w, H_w) \setminus Q_p(T_w,
	  H_c)$ of queries to perform

Tags further away from the root are less "related" to the original query, but
searches for them are more likely to succeed (for rare searches), so the
algorithm should proceed by searching near the root, then further up the tree.

MORE same principle about concurrency as mentioned before about tag/tgraphs.


### Ranking

#### Combining results from different queries

Given
:	- a working tree $T_w$ of tags
	- a map $H_w$ of each $t \in T_w$ to its "working `index`" set
	- a map $H_c$ of each $t \in T_w$ to its "queried `index`" set
	- a map $R_c$ of each $t \in T_w$ to (a map of each "queried `index`" $h
	  \in H_c[t]$ to its results set)
Return
:	- a results map $R = \{(d_i, w_i)\}$ from documents to their weights





## Optimisations

### Querying an `index` or `tgraph` for presence of a source tag

Bloom filters

### Querying an `index` or `tgraph` for weight of an external target

...


## UI

### Components

### Behaviour


# Design

## Objectives

## Assumptions

### Abstract storage network

Our search system assumes that its data objects are located on some abstract
lower-level storage network. Data objects can always be retrieved, instead of
being stored locally with its maintainer, who may be offline. This simplifies
our design, since it allows us to avoid dealing with the issue of churn by
delegating it to an independent component. [EXTN]

This also forces us to consider a iterative routing algorithm rather than a
recursive one, since data objects are "dumb" and cannot respond to dynamic
queries. Instead, a requestor must retrieve the data, process it themselves,
then pull in further data, etc.

Any distributed storage network that has a global address scheme (such as a
binary-key address space) would be suitable, since pointers to objects can be
represented simply as its address. This includes all Distributed Hash Tables
(DHTs), as well as more complex cryptokey-based addresses such as Freenet's
Signed Subspace Keys network.

### Underlying social network

The initialisation algorithm assumes a abstract lower-level social network
where it can look for friends to query for pointers onto the meta-routing and
routing planes.

The network is modelled as a directed weighted graph; arcs represent a degree
of trust by the source node in the target node, and arc weights are restricted
to the interval $[0,1]$.

This model is sufficiently general for our purposes. Many social networking
websites only recognise mutual friendship; this is a degenerate form of the
model, where all weights are constant and all arcs have a reverse-direction
counterpart.

The meta-routing and routing planes also form what is essentially a social
network. However, its pointers carry semantic information (each mapping has a
source tag) and are intrinsic to our search system; by constrast, the abstract
social network used for initialisation carries no semantic information and is
independent of our system. To highlight this difference, we refer to a node on
the social network as an "identity", and arc weights as "identity scores".

MORE talk about churn, virtual social networks (WoT on Freenet's SSK), etc

MORE proxy services

## Identity-object pointers

vs. all-data-in-identity and identity-identity pointers

## Object-object pointers vs identity-object pointers

to decrease the number of identity-object pointers

## Mutable-object pointers vs immutable-object pointers

## Zero-weight pointers

The current design can only represent the presence of a semantic relationship,
and not its absence. This is a problem: any distributed system has to be able
to deal with incomplete information, but here there is no way to tell if the
absence of a pointer is due to incomplete information, or explicit rejection
of the semantic relationship that the pointer represents. This is important for
when (eg.) we want to combine weights from multiple sources - we need to know
whether others disagree with a given mapping, or merely don't know about it.

Requiring explicit "zero-weight" pointers is not acceptable for our purposes,
since this equates to defining *something* (either a relationship or its
absence) between *all* possible pairs of objects encountered; this results in
quadratic data growth, which is not scalable.

Instead, we will look at heuristics that attempt to resolve this ambiguity.

For an object $O$ consisting of mappings, such as `index` and `tgraph`, we
observe that the presence of a mapping $(s, t)$ indicates that the maintainer
knows of the existence of $s$ and $t$, and has enough information to make
judgements about them.

Define $O$ "knows about" $s$ to mean $s \in dom(O) \cup img(O)$. Since the
meaning of $(s, t)$ depends only on $s$ and $t$, the maintainer also has enough
information to decide whether to include mapping between *any* source and *any*
target that it "knows about". Conversely, for any given mapping $(x, y)$ *not*
present in $O$, if it "knows about" both $x$ and $y$, then it seems reasonable
to conclude that the absence of the mapping "probably" represents a zero-weight
pointer (non-relationship), rather than "missing information".

- For a `tgraph` $g$, we guess that any $(t_1,t_2) \notin g$, with $t_1, t_2
  \in dom(g) \cup img(g)$, is "probably" a zero-weight pointer and not "missing
  information".
- For an `index` $h$, we guess that any $(t,d) \notin h$, with $t \in dom(g)$
  and $d \in img(g)$, is "probably" a zero-weight pointer and not "missing
  information".

Specific examples of this general principle, as well as applications of it,
will be explored further in relevant sections of the [Algorithms](#algorithms)
chapter.

For an object consisting only of source-less pointers, such as `ptable`, there
is no information within a single object that could be used for any heuristic
to distinguish the two cases.^[Using the heuristic described above for mappings
by treating the pointers as mappings from a single source doesn't help: a pair
(X,Y) cannot exist with the required properties since we only have one source.]

However, in the specific case of `ptable`, we could use the links present in
the social network to infer more information: eg. identities who are friends
are likely to "know about" similar sets of objects. In practice, such methods
are hard to get accurate^[A basic heuristic would be to assume that some
fraction of an identity's friends "know about" each object that its `ptable`
points to; however the real fraction is unlikely to be near-constant over all
objects, so the scheme would greatly disadvantage rare objects. We could take
this into account and estimate the "knows about" fraction based on the fraction
of identities that explicitly reference the target, but this is becoming more
and more complicated with increasingly hand-waving arguments.], and probably
won't provide significantly enough benefit to justify the additional complexity
- the social network should mitigate most serious attempts to abuse the system.
MORE

## Negative-weight pointers

A related issue is negative-weight pointers, which would represent a judgement
that the target is malicious (in some sense), rather than neutral or "useless".
In a network where it's possible to act aggressively towards particular nodes,
these weights could provide information on who to attack (or equivalently, set
up defences against), and in what way.

As it stands, our search system is a "dumb" network of data; the only way of
interacting with other nodes is by publishing data objects for other nodes to
read. We are unable to see other nodes' read requests, so it's impossible to
attack a particular node. Hence, negative-weight pointers are not useful here.

There are several other complications with negative-weight pointers in general.
These would be relevant if our search system is adapted into a form where one
*can* perform targeted acts of aggression.

- If positive-weight pointers are taken to be probabilities, it's not obvious
  what negative-weight pointers should mean. If the semantics of the data
  structure are not well-defined, the algorithms that use it cannot be, either.
- Depending on the algorithm used to combine weights from multiple sources,
  negative weights may allow the weight system itself to be used as an attack
  vector. (Otherwise, this was already possible with positive-only weights and
  the introduction of negative weights makes no difference.)
- MORE


# Analysis

## Data extraction and processing

last.fm, flickr

social network - relatively easy

### Transforming a simple graph into a `tgraph`

tgraphs arcs have weight and direction

## Generation of test networks

### Inter-object properties

- neighbour count (ie. degree) distribution
- neighbour type distribution

### Intra-object properties

- semantic unity (how "related" its tags are)
- semantic specialty (how "general" its tags are)

### Generation algorithms:

- scale-free/small-world network with preferential attachment (Barabási-Albert model)
- other structures?


## Simulation

### Request models

### Network conditions

- perfect conditions
- random failure
- malicious attacks
  - attacks vs most well-connected nodes


# Java class definitions

Note: I started doing these, then thought I'd leave it for the coding stage;
Here's what I have so far.


~~~{.java}
	interface NetworkStorageAdapter {

		Index getIndex(ObjectID id);

		TGraph getTGraph(ObjectID id);

	}
~~~


~~~{.java}
	interface SocialNetworkAdapter {

		Map<Identity, IdScore> getFriends(Identity id);

		PTable getPTable(Identity id);

	}
~~~


~~~{.java}
	interface SeedSetGetter {

		/**
		** @param self
		**  	A root identity (typically our own)
		** @return
		**  	A set of seed identities, with corresponding weights
		*/
		Map<Identity, IdScore> getSeedSet(Identity self);

	}
~~~


~~~{.java}
	interface TGraphComposer {

		/**
		** @param tables
		**
		** @return
		**  	A set of mapping targets (which can be a tag or tgraph) and
		**  	their weights; the source of each mapping being the source tag
		**
		*/
		Map<TGraphEntry, EntryWeight> compositeTGraphNode(Map<TGraph, EntryWeight> , Tag source);

	}
~~~


~~~{.java}
	interface PTableComposer {

		/**
		** @param tables
		**  	A set of ptables, each being mapped to its identity's score.
		** @return
		**  	A ptable that combines all of the input information, with
		**  	$dom(p) = \bigcup dom(p_i)$.
		*/
		PTable composite(Map<PTable, IdScore> tables);

	}
~~~
