% Appendices
% Ximin Luo

# Notation

## Glossary

arc
:	A directed relation $e = (v_s, v_t)$ from node $v_s$ to node $v_t$.
degree, in-degree, out-degree (of a node-set $V$)
:	See "neighbour (of a node-set $V$)". the *-degree is just the number of
	*-neighbours
document
:	A storage object that can be the target of some query. This could include
	(eg.) multimedia or software; for simplicity, we'll refer to these all as
	"document".
identity
:	A node ("user") on the social network
independent union (of a set of probabilities $P$)
:	The probability of at least one event in $P$, assuming all the events are
	independent, given by $1 - \prod_{p \in P} (1 - p)$.
local view
:	For a remote object $x$, the local view holds the parts of $x$ that have
	been retrieved from the network, ie. data that is immediately available to
	the local system. It can distinguish between items found not to exist in
	$x$, and items not yet loaded.
neighbour, in-node, out-node (of a node $v$)
:	A node separated from $v$ by a single arc. We abbreviate "in-neighbour",
	"out-neighbour" to just "in-node", "out-node". We denote the set of all
	neighbours, in-nodes, out-nodes, of $v$ as $\nbrv$, $\predv$, $\succv$.
neighbour, in-node, out-node (of a node-set $V$)
:	We define $\nbrV = (\bigcup_{v \in V} \nbrv) \setminus V$; and $\predV$,
	$\succV$ similarly.
node
:	In the context of a graph or a network, a unique individual
resource relationship, route
:	We write $p \rightarrow^t p'$ to mean that $p$ points to $p'$ via tag $t$.
	In the relevant contexts (e.g. if $p$, $p'$ are tgraphs / indexes), this
	also means that $p$ defines an arc $(t, p')$ as a resource.
tag
:	A semantic unit used to describe documents in a useful way to end users.

## Data structures

Here, we document the notation we use for describing the data structures we
use. All are implicitly finite in size.

Partial function $f \subseteq X \to Y$
:	This is non-standard, but $f : X \to Y$ is ambiguous - existing literature
	uses it to mean both a partial or a total function, depending on author.

### Simple objects

Tuple $X = ( a,b,\ldots )$
:	an ordered container of items, of fixed size
:	- the parentheses may be omitted when the context is clear
Union $U = ( a|b|\ldots )$
:	a container holding a single value of any of the specified types
:	- the parentheses may be omitted when the context is clear
Map $M = \{ x : y \}$
:	a container that maps[^mapfn] $x$ to $y$.
:	- write $y_x$ to mean "the $y$ that	$x$ maps to".
	- let $x \in M$ mean the same thing as $x \in \dom M$.
	- the braces may be omitted when the context is clear
List $L = [ x_i ]_{i}$
:	an ordered container of items, of unfixed size

[^mapfn]: This is equivalent to a partial function: $M = \{ x_i \in X \mapsto
y_i \in Y \}_i$ means the same thing as $M \subseteq X \to Y$; however, the
former is a better description of a static data structure.

### Composite objects

We make heavy use of these container objects:

- maps $V_A : V \to A$ of nodes to their attributes.
- maps $E_A : E \to A$ of arcs to their attributes.

These are used in various combinations to represent graphs, inverted indexes,
etc.

For any set $E \subseteq V_s \times V_t$ of arcs, define:

- $\src E = \{ v_s \in V_s : \exists v_t . (v_s, v_t) \in E \}$ ie. the set
  of nodes that the arcs point from.
- $\dst E = \{ v_t \in V_t : \exists v_s . (v_s, v_t) \in E \}$ ie. the set
  of nodes that the arcs point to.
- $\rft E = \src E \cup \dst E$ ie. the set of nodes that E refers to.

For convenience, let this also apply to arc-attribute maps, ie. $\rft E_A =
\rft E$.

### System-relevant objects

With no other context or indication, the following single-letter symbols refer
to the following object types. Capitalised symbols refer to the set of all
objects of the given type; this is also partly reflected in the source code.

-----------------------------------------------------------------------
Symbol          Object type
--------------- -------------------------------------------------------
$d$             document

$t$             tag

$g$             `tgraph`

$h$             `index`

$p$             `ptable`

$z$             identity

$s$             node attribute (identity score)

$w$             arc attribute (tag-tag weight or tag-doc weight)

$u$             node attribute (tag weight or resource value)

------------------------------------------------------------------------

Details about these object types, their structure and semantics, are contained
in the design document.


# Bibliography

etc etc etc
[MORE]


TrueSkill http://research.microsoft.com/en-us/projects/trueskill/details.aspx

Dangalchev, C. Residual closeness in networks, 2006.


## Comparison

Our design differs considerably from these; for example, REMINDIN's design is
more ontology focused, whereas ours draws from existing non-semantic routing
principles, DHTs in particular. Our design also has a well-defined (albeit
underdeveloped) model of the address space (unlike Harnessing). [MORE]


# Derivations

(put long derivations here)


# Future work

(basically scrape all the [EXTN] tags from the rest of the text)


# Meta

These documents were prepared in [pandoc markdown](http://johnmacfarlane.net/pandoc/).

## Interface

Clicking the arrows next to the menus will toggle the visibility of their
children. Shift-clicking will do this recursively for all descendents at all
levels.


# Unfinished notes

## Optimisation

[MOVE] to appendix

### Data structures

- `ptable`
	- quick partition of `index` vs `tgraph` nodes [$G_s$, $H_s$]
	- optionally order these by their score [possible future use]

- `tgraph`, `index`
	- where applicable:
	- quick lookup of node (and weight)
	- quick lookup of node's out-arcs (and weight) [routing, naming]

- `index`
	- quick partition of tag's to-`index` vs to-document arcs
	- optionally order these by their score [routing]

- $\breveg$
	- same as `tgraph`

- $p_s$, $\breveg$, $\breveG$, $\breveH$
	- might want to make these use CombinedWeight objects instead of a float
	  "weight", which in the future could be expanded to include a variance...

- $\breveT$
	- quick lookup of node (and weight)
	- quick iteration through all nodes [$\breveQ$]
	- quick comparison of nodes by their distance ordering [$\breveP$]
	- quick lookup of node's in-arcs (and weight) [$\breveQ$]

- $\ddotg \in \img \breveG_*$, $\ddoth \in \img \breveH_*$
	- quick lookup of node (and weight)
	- quick iteration through all nodes, arcs [$\breveg$]
	- quick lookup of node`s in-arcs (and weight) [routing, naming]
	- quick lookup of node's out-arcs (and weight) [maybe needed by some
	  scoring modules]
	- quick one-time check that all of a node's out-arcs (and weight) have
	  been retrieved from the network [routing, naming]

- $\breveQ$, $\breveR$
	- quick iteration of all lookups/results [$\breveP$, $\breveh$]
	- an advanced implementation would allow items to be added and dynamically
	  ordered in priority, bypassing the need to have $\breveP$, $\breveh$.

### Retrieval of remote objects

Usually we only need to retrieval part of a `tgraph` or `index`, eg. the weight
of a single node, or its out-arcs.

- eg. for quick "no" answer on lookups of storage objects - bloom filters

### Caching storage objects

- eg. cache commonly-retrieved objects like `ptable`s

The contact layer is independent of any query, so this can be done in the background
at any time. We can cache data for the layers above, which will help to
increase performance for future queries. etc...

[MORE] on incremental updates etc.

### Incremental state updates

- eg. when updating $\breveG$ from $\breveG_*$, we should only need to
  recalculate the parts that are affected by the updated....

## Test networks

### Inter-node properties

- neighbour count (ie. degree) distribution
- neighbour semantic relation distribution

### Intra-node properties

- semantic unity (how "related" its tags are)
- semantic specialty (how "general" its tags are)

### Generation algorithms

- Use network formed by extracted data ("real world")
- Barab√°si-Albert model (preferential attachment)
  - scale-free
  - not small-world; according to wikipedia:
    - clustering coefficient is power-law, similar to hierarchical networks
    - small-world networks have constant clustering coefficient
- TODO etc. read up on network theory.
- hierarchies
- other structures?

Ideally we want a single algorithm which takes as input, various parameters for
the properties listed in the previous two sections, and outputs a random graph
with those properties.

## Simulation

### Request models

### Network conditions

- perfect conditions
- random failure
- malicious attacks - under the assumptions of "abstract storage network", only
  attacks vs the entire network can occur on the naming / routing planes.
  attacks vs individuals on the social plane is a separate topic, ignore here
	- attacks vs most well-connected nodes
	- MORE

