== Primitives ==

Address
Identity
Attribute
Composite<A extends Attribute>

Weight implements Attribute
Score implements Attribute
CompositeScore extends Score implements Composite<Score>
CompositeWeight extends Weight implements Composite<Weight>

PTable<S extends Score>
TGraph<U extends Weight, W extends Weight>
Index<W extends Weight>

TGraphAddr extends Address
IndexAddr extends Address
AddressScheme (some sort of List+Graph)

== Init ==

CompositePTable<S extends Score & Composite<Score>> extends PTable<S>

CompositeScore combineScores(Map<PTable, Score> sources, Index|TGraph item)

== Meta-routing ==

Map<TGraphAddr, LocalTGraphView>
Map<TGraphAddr, Score>
CompositeTGraph<U extends Weight & Composite<Weight>, W extends Weight & Composite<Weight>> extends TGraph<U, W>
AddressScheme<Integer> scheme

--
CompositeTGraph<etc> combineTGraphs(Map<LocalTGraphView, Score> sources, Tag|Arc item)
--
Distance getDistance(Tag src, Tag dst, U srcweight, U dstweight, W arcweight)
int compareDistances(Distance d, Distance d)
--
Score getScoreFor(LocalTGraphView view, Map<LocalTGraphView, Score> sources)

== Routing ==

Map<IndexAddr, LocalIndexView>
Map<IndexAddr, Score>
Map<IndexAddr, Set<String>>
Map<IndexAddr, LocalIndexView>

--
List<$2<IndexAddr, Tag>>(Map<LocalIndexView, Set<String>> queries, AddressScheme<Integer> scheme)
--
Score getScoreFor(LocalIndexView view, Map<LocalIndexView, Score> sources)
--

== Ranking ==

Map<Address, W extends CompositeWeight>

== Interface with storage layer ==

<I extends Identity,
 S extends Score>
Map<I, S> getFriends()

<I extends Identity>
PTable getPTable(I id)

<G extends TGraphAddr,
 T extends Tag,
 A extends Attribute>
Map<T, A> getTGraphOutgoing(G addr, T srctag)

<G extends TGraphAddr,
 T extends Tag,
 A extends Attribute>
A getTGraphTagAttr(G addr, T srctag)

<H extends IndexAddr,
 T extends Tag,
 A extends Attribute>
Map<D, A> getIndexOutgoing(H addr, T srctag)

